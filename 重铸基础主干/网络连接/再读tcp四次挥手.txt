## tcp四次挥手

TCP三次握手以后，开始send/recv数据了。
这个时候双方都是独占对方的ip地址：端口号的。

但是，当双方数据交互完成后，是不是需要释放ip地址：端口号资源？
那这个释放的过程就是TCP的4次挥手。
下面简单的描述一下这个释放的过程，然后再分析其中的设计原理。

假设是A和B现在在进行TCP通信。
1. A发送结束数据包给B，告诉B：我不发送数据了，要结束通信了。
	* FIN标记置为1，表示不发送数据给B了
	* 在该报文中带上自己的seq=x，以防止B收到该消息后乱序
2. B收到的A发送的结束消息以后，先发送数据包给B自己已经收到该消息
	* ACK标记置为1，ack字段带上A下一个数据包的起始序号：x+1
	* 在该报文中带上自己的seq=y
3. 等了一会儿，B也不发送数据了，它发送数据包给A，告诉A自己也不发送数据了，结束通信吧。
	* FIN标记置为1，表示不发送数据给A
	* 在该报文中带上自己的seq=z
4. A收到B的发送结束数据包以后，告诉B：好的，我知道你要结束了，从此以后不接收你的消息了。
	* ACK标记置为1，ack字段取z+1
	* 带上自己的seq=x+1
	
tcp的双方A和B在syn seq以后，双方A和B都是会send msg。
因为为了保持可靠性，send req和send rsp是对应的。
不管是多个req对应一个rsp，还是一个req对应一个rsp。
rsp就是ACK。

所以在A和B结束的时候，都必须确认自己不会在send msg，通信叫做全双工。
这样说了以后，上面的流程就好理解了。
A发了自己的结束请求以后，B通过发送ACK消息告诉A：收到了该请求，并且不会再收任何来自A的数据包（重点）。
过了一会儿，B觉得自己也表达完了，不想给A说话了。
所以B就发送自己的结束会话请求，A收到了该请求，就通过发送ACK消息来告诉B：收到了该请求，并且不会再收任何来自B的数据包了。

#TCP释放方案的异常情况处理#
但是这里就有一个问题了：假如在4次挥手的时候发生了丢包，怎么办？
这是影响TCP健壮性的一个大问题，TCP怎么可能不考虑这种情况。
从一个方案的设计来说，这是影响安全性的，它属于异常情况处理，是必须要解决的。

第一步，也就是A发送结束FIN消息，结果这个包丢了，怎么办？
A在发送结束请求FIN消息（seq=x）以后，会启一个FIN_WAIT_ACK的定时器，然后如果在这个定时器周期内A没有收到FIN的响应ACK消息。
A会重新发送FIN消息（seq=x），这个消息跟之前发送的一毛一样，直至B收到该FIN消息。

第二步，B收到A发送的FIN消息，它发送了响应ACK，这个响应ACK在传输过程中丢了，怎么办？
这个时候，如果ACK带数据了，B也会给这个ACK消息启一个定时器，超时没有收到响应，也会重发这个ACK。
如果ACK只是单纯的响应，并没有携带任何数据内容，那么B也不会做任何措施，等待A的定时器超时去重传第一步的FIN消息。

第三步，如果B发送FIN消息在传输过程中，丢包了，怎么办？
这个处理的办法跟第一个FIN消息丢包了的处理办法一样。

第四步，如果A收到B发送FIN消息，它发送了响应ACK消息，但这个ACK消息在传输过程中丢了，怎么办？
由于这个ACK肯定是不带任何数据内容的，所以它是不会有响应的。
那么它只有一种情况，等待B的定时器超时，重新发送FIN消息。
由于此时的定时器都是等待响应的定时器，所以它们的时间都是2MSL（报文最大生命周期）。
这也是每个面TCP知识点的人都喜欢问这个的原因。







	

	

