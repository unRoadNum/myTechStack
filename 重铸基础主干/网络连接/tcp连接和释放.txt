## tcp三次握手和四次挥手
我们都知道tcp协议的目的是实现可靠的传输层协议。

那怎么能实现可靠的传输呢？
可靠要求数据包不会因为各种原因在网络产生乱序、丢包这种灾难发生。

那又怎么才能保证数据包在传输的过程中乱序和丢包呢？
乱序这个我们能想到的办法就是接收双方都给自己数据包增加一个序号字段。
这样，接收方收到数据包后根据序号就可以正确拼出发送方想表达一个什么意思。
而如果丢包了，就会出现：
发送方将数据包发送了，但是数据包在网络传输过程中因为各种不知名原因丢了，接收方没收到。
接收方一直在等，但是发送方并不知道丢了，还不发？（ps：你说气人不气人）
为了解决这个问题，我们可以启一个定时器Timer，发送方发送完一个数据包后，定时器开始计时，
如果定时器超时，发送方就认为该数据包在网络传输中丢包了，然后再发送一遍该报文给接收方。

这样，貌似就解决了可靠传输问题。
但是，你发没发现，这其中还存在这问题。
发送方和接收方并不知道什么时候开始要进行可靠传输。
所以，我们需要有一个双方约定开始的过程。

因为这个约定开始的过程以后，双方就开始正式发送数据包了。
所以你必须让数据传输的双方都清楚第一次将接收到的数据包的序号是多少，注意是”将“，也就是没收到之前就要知道。
这样做的原因是为了收到数据包以后处理更加方便。

为什么呢？
如果不知道的话，有这种情况：
发送方发的1~n个数据包，第一包在传输过程中丢了，接收方（指的是第一次数据包传输的过程中担任接收的一端）误将第二包当成第一包。
接收方以为自己收到的n-1个包是全部包，将n-1个包，交给另一个模块处理了。
结果发送方重传了第一包，这个时候n-1包已经交给另一个模块处理了，怎么办？难道从另一个模块将n-1个包再要回来吗?手动笑哭-_-
接收方发送的第一个响应包丢了情况类似。

这样就引出了tcp的三次握手的同步seq过程。
我认为它的出发点并不是要建立连接什么东西，它只是同步seq过程。
tcp的面向连接这个概念应该是tcp出现以后应用过程中总结出来的一个概念。

那再考虑另一种情况：
A和B好不容易同步了seq，传输了几秒钟，C又想和B传输数据包。
那B会和C又开始传输数据包，不通知A吗？
所以，又引入了另一个设计：tcp的四次挥手。
（ps: 我喜欢设计这个词语，并不喜欢规定这个词语。一个事物的出现往往是为了解决某一个问题的，而不是凭空出现的。所以设计更符合这种语境。）