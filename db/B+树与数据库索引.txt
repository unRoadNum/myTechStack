# B-树和B+树

引入
***
二叉排序树->
	二叉平衡树->
			B-树->
				B+树（查找、删除和增加跟B-树一毛一样）

B+树特点
***				
1. 两个节点指针：
	** 根节点root指针
	** 叶子节点链表的头节点
2. 不管查找成功与否，都走一个从根到叶子节点的路径。

数据库索引
***
1. 在数据库系统的使用过程当中，数据的查询是使用最频繁的一种数据操作。
	** 最基本的查询算法当然是顺序查找（linear search），遍历表然后逐行匹配行值是否等于待查找的关键字，其时间复杂度为O（n）。
		> 但时间复杂度为O（n）的算法规模小的表，负载轻的数据库，也能有好的性能。 
		> 但是数据增大的时候，时间复杂度为O（n）的算法显然是糟糕的，性能就很快下降了。
2. 好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary search）、二叉树查找（binary tree search）等。
如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上。
	** 二分查找要求被检索数据有序
	** 二叉树查找只能应用于二叉查找树上
3. 但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），
所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构。
这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。

B+树在数据库索引中的应用
***
目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构
1. 在数据库索引的应用
	** 在数据库索引的应用中，B+树按照下列方式进行组织：
		> 叶结点的组织方式 。B+树的查找键 是数据文件的主键 ，且索引是稠密的。
也就是说 ，叶结点 中为数据文件的第一个记录设有一个键、指针对,该数据文件可以按主键排序，也可以不按主键排序:
			① 数据文件按主键排序，且 B +树是稀疏索引 ，  在叶结点中为数据文件的每一个块设有一个键、指针对。
			② 数据文件不按键属性排序 ，且该属性是 B +树 的查找键，叶结点中为数据文件里出现的每个属性K设有一个键、指针对，其中指针执行排序键值为 K的 记录中的第一个。
	** 非叶结点 的组织方式。B+树中的非叶结点形成 了叶结点上的一个多级稀疏索引每个非叶结点中至少有ceil( m/2 ) 个指针，至多有 m 个指针。
2. B+树索引的插入和删除
	** 在向数据库中插入新的数据时，同时也需要向数据库索引中插入相应的索引键值 ，则需要向 B+树 中插入新的键值。即上面我们提到的B-树插入算法。
	** 当从数据库中删除数据时，同时也需要从数据库索引中删除相应的索引键值 ，则需要从 B+树 中删 除该键值 。即B-树删除算法
	
为什么要用B+树
***
二叉查找树进化品种的红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构。
一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。
这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。
换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。为什么使用B-/+Tree，还跟磁盘存取原理有关。
1. 局部性原理与磁盘预读
　　由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。
为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。
这样做的理论依据是计算机科学中著名的局部性原理：
　　当一个数据被用到时，其附近的数据也通常会马上被使用。
　　程序运行期间所需要的数据通常比较集中。
　　由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。
　　预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。
 
    我们上面分析B-/+Tree检索一次最多需要访问节点：
     h =log(m/2)(n+1)/2+1
    
    数据库系统巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B- Tree还需要使用如下技巧：
    每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。
B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O（h）=O（logmN）。一般实际应用中，m是非常大的数字，通常超过100，因此h非常小（通常不超过3）。
　　综上所述，用B-Tree作为索引结构效率是非常高的。
　　而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O（h），效率明显比B-Tree差很多。

