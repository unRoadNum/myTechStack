# 从重复定时器到单例模式

***
最近在开发新功能时，出现了一个问题，想起来挺典型的。
我想把尽量多的异常强制发现在编译期，这样就可以在支撑的时候，少出现问题，能真正的掌控程序。
好希望换个环境，去做一些有意思的事情，让工作能更走近理想。也许像我这个年龄，谈理想都会被认为是一个笑话，
或者说谈技术进步，都会被人们认为不可思议。

***
问题发生在我需要关闭某事件的定时器，却发现根本没有生效。事件的回调函数还是执行了。
找了很久的原因，才找到：
应用模块为了限制定时器的数量，在平台定时器上层做了限制，只能在同一个实例中启4个定时器。
而停定时器的时候，是通过遍历实例定时器存储结构来决定的，类似于如下:
```
for(int loop = 0; loop < 4; loop++)
{
	if(timeTag == pstInst->stTimer[loop].timeTag)
	break;
}

if(loop < 4)
	stop_timer(pstInst->stTimer[loop].timeHandle);
else
	return fail;
```
这样导致的结果就是我们可以set相同timeTag的定时器，但是stop的时候就不一定是你当初set的定时器了。
它会找到实例定时器存储结构最先匹配到的定时器去stop。

***
近期出去找工作，问到了单例模式，我就想到了是否我可以将每个定时器都做成一个单例。
但是需要解决的如下几个问题:
	1. 单例的类是否可以是子类
	2. 假如把每个定时器都做成单例，是否启一次定时器需要创建销毁一次计时。
	
