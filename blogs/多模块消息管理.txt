# 多运行模块消息管理

# 问题引出
***
最近研究了一下系统的消息管理，针对某一些重要的点，有了一点感悟，记录一下成长。
在系统中，多个”独立“运行的模块是需要消息传递的。
多"独立"运行模块的消息都是统一管理的，这也是软件设计的中心思想。消除重复的关键就是统一管理。

# 多"独立"运行模块
***
这里的多"独立"运行模块，除了通常意义上的线程，进程以外，还包括那些具有"独立"运行特征的纤程。
本文以后的模块专指这可“独立”运行模块。

# 消息管理
***
1. 消息的正文
通常消息的正文设计，都是如下：
```
typedef struct 
{
	...
	void *pvMsgBuff;
	UINT32	ulMsglen;
}XXX_MSG_T;
```
至于*pvMsgBuff填充的内容，那是模块与模块之间消息的编解码问题。由模块自己进行处理，不会进行统一管理。
如果涉及到多个模块有相同协议，可以在进行多子模块统一编解码。
2. 消息的控制头
消息的控制结构涉及到多种模块的消息，所以得统一消息控制。根据如下的设计规则统一消息控制结构：
						统一消息控制结构
							+
							|
					+ - - - + - - - - +
				  线程控制			纤程控制
```
typedef struct
{
	UINT32  ulSrcProcId;
	UINT32	ulDstProcId;
	
	UINT32	ulPriority;
	...
}XXX_MCB_HEADER_T;
```
3. 消息的管理
需要给每一个模块维护一个消息队列。
如果是纤程的话，需要给调度线程维护一个消息队列。调度线程根据消息队列中的消息来确定纤程的运行顺序。
可"独立"运行模块所有的消息都会经过消息管理模块。消息管理模块在系统初始化的时候，建立消息管理表，
表中维护每个可“独立”运行模块的消息队列。
当实际系统运行的时候，消息经过管理模块，只需要将该消息根据优先级加入消息队列即可。
当然，消息队列表都是要读入内存的，要不多个线程怎么能同时访问到该模块的表。
运行/调度线程只需要读取该队列中的消息来实现自己不同的业务。