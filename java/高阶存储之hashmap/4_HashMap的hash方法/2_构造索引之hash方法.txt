#hash方法#

回到HashMap构造索引这个话题上来。

如果HashMap利用key.hashCode方法生成的散列值直接去作bucket的标号，有问题啊。
虽然key.hashCode生成的散列值不同对象是不同的，但是它返回的是一个有符号的int值。
一个32位的有符号int值范围是从2的-31次方到2的31次方-1，即-2147483648到2147483648。
需要建立一个42亿的数组，现有的内存是不允许出现这种这么大的数组的。

之前初始化的时候，HashMap的初始数组大小才是16。

所以这个key.hashCode不能拿来直接用的。
java想到的策略是除留余数法。 
即，先对数组的长度取模运算，得到余数用来作bucket的下标。

在jdk源码中如下：
```
bucketIndex = indexFor(hash, table.length);
```
而indexFor方法是这样定义的：
```
static int indexFor(int h, int length) {
	return h & (length - 1);
}
```

刚开始看这个方法这么做是有点奇怪的。
但仔细想，"与"操作的结果就是散列值的高位全部取0，只保留低位用作bucket下标。

就拿bucket初始长度是16来举例， 16 - 1 = 15。
15的2进制表示就是00000000 00000000 00001111。
那这个2进制做与操作，就是截取了最低的4位的值。

好像很完美，但是一开始java就发现了问题，就算用最低的4位做“&”操作，碰撞还是很严重。
如果你以为equals重写了hashCode的话，写的不好就更严重了。
这个时候，java又自己鼓捣了一个"扰动函数"来做在indexFor之前hash。
所以平常我们说的hash算法在java中是"扰动函数" + "indexFor"一起的功劳。

#"扰动函数"是怎么回事呢？#
java8中是这样做的，如下：
```
static final int hash(Object key) {
	int h;
	return (key == null)? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

下面看一下"扰动函数"的牛逼之处。
	  h = hashCode(): 	1111 1111 1111 1111 1111 0000 1110 1010 	调用hasdCode()
------------------------------------------------------------------------------
				  h :	1111 1111 1111 1111 1111 0000 1110 1010
			h >>> 16:	0000 0000 0000 0000 1111 1111 1111 1111		计算hash
	  
hash= h ^ (h >>> 16):   1111 1111 1111 1111 0000 1111 0001 0101     
-------------------------------------------------------------------------------


		(n - 1)&hash:	0000 0000 0000 0000 0000 0000 0000 1111		计算下标
						1111 1111 1111 1111 0000 1111 0001 0101 
--------------------------------------------------------------------------------
						0000 0000 0000 0000 0000 0000 0000 0101 = 5
						
将hashCode无符号右移16位，然后再与16位异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。
而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来了。

而且这个有外国友人做过实验，用了扰动函数以后，碰撞次数优化了30%左右。

至此，hash总算搞出来，暂时收工，好累。

