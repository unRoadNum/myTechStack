GC需要面对的问题有3个：
1. 那些对象需要回收？
2. 何时回收这些对象？
3. 如何回收这些对象？

#最早的办法（已被弃用）： 引用计数法#
它的思想很简单：对一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1;
当引用失效时，引用计数器就减少1。只要对象A的引用计数的值为0，则对象A被回收。

很显然，当出现循环引用的时候，引用计数器就永远不为0，所以被弃用。

#标记-清除法(Mark-Sweep)#
标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。

在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。
因此，未被标记的对象就是未被引用的垃圾对象。
然后，在清除阶段，清除所有未被标记的对象。

它的最大问题是会产生内存碎片。
回收后的空间是不连续的。对于以后要分配大对象，不连续的内存空间的工作效率要低于连续空间。

#复制算法(Coping)#
它的核心思想是：将原有的内存分为两块，每次只使用其中一块。在垃圾回收时，将正在使用的内存中的存活对象复制到未被使用的内存块中。
之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。

如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，所以复制的算法效率很高。
而且又由于对象是在垃圾回收过程中统一复制到新的内存空间中，所以没有碎片。
但是，复制算法的代价缺点是将系统内存折半，因此，单纯的复制算法也很难让人接受。

因此，该算法仅被用于新生代串行回收器中。
新生代分为eden空间、from空间和to空间3个部分。
其中from和to空间可以视为用于复制的两块大小相同，地位相等，且可进行角色互换的空间块。
（复制算法比较适合新生代。因为在新生代，垃圾对象通常会多于存活对象，复制算法的效果会比较好）

#标记-压缩算法(Mark-Compact)#
标记-压缩算法是一种老年代的回收算法。

标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记。
然后，将所有的存活对象压缩到内存的一端。
之后，清理边界外的所有空间。

这种方法既避免了碎片的产生，又不需要两块相同的内存空间。

#增量算法#
对于大部分的垃圾回收算法，在垃圾回收过程中，应用软件将处于一种Stop the World状态。
在Stop the World状态下，应用软件所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。

增量算法的基本思想是：垃圾收集线程和应用程序线程交替执行。
每次，垃圾收集线程只收集一小片内存空间，接着切换到应用程序线程。
依次反复，直到垃圾收集完成。

由于在垃圾回收的过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。
但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，系统吞吐量的下降。

#分代思想#
它将内存区间根据对象的特点分成几块，根据每块内存区间的特点，使用不同的回收算法，以提高垃圾回收的效率。






