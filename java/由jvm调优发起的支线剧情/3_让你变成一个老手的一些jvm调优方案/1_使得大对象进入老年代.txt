虽然在大部分情况下，将对象分配在新生代是合理的。
但是，对于大对象，这种做法是值得商榷的。
因为大对象出现在新生代很可能扰乱新生代的GC，并破坏新生代原有的对象结构。

因为尝试在新生代分配大对象，很可能导致空间不足，为了有足够的空间容纳大对象，jvm不得不将新生代中的年轻对象挪到老年代。
因为大对象占用空间多，所以，可能需要移动大量小的年轻对象进入老年代，这对GC来说是相当不利的。

基于以上原因，可以将大对象直接分配到老年代，保持新生代对象结构的完整性，以提高GC的效率。

如果非常不幸的，一个大对象同时又是短命的对象，假设这种情况出现的比较频繁，那么对于GC来说将是一场灾难。
原本应该用于存放永久对象的老年代，被短命的对象塞满，这也意味着对堆空间进行洗牌，扰乱了#分代内存回收#的基本思路。
因此，在软件开发过程中，应该尽可能避免使用短命的大对象。

可以使用参数-XX:PretenureSizeThreshold设置大对象直接进入老年代的阈值。
当对象的大小超过这个值，将直接在老年代分配。
但是，该参数只对串行收集器和新生代并行收集器有效，并行回收收集器不识别这个参数。

例如:
-XX:+PrintGCDetails-Xmx20M-Xms20M-XX:PretenureSizeThreshold=1,000,000
这样可以将1MB以上的对象直接在老年代分配。




