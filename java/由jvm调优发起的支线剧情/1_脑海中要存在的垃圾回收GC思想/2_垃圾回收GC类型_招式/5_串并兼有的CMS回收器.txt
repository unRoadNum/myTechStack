和并行回收器不同，CMS的关注点在系统停顿时间。

CMS是Concurrent Mark Sweep的缩写，意为并发标记清除。
从名字就可以看出来，它使用的标记-清除算法，同时它又是一个使用多线程并行回收的垃圾收集器。

CMS工作的时候，主要步骤有：
初始标记-->并发标记-->重新标记-->并发清除-->并发重置

根据标记-清除算法，初始标记、并发标记和重新标记都是为了标记出要回收的对象。
并发清理，则是在标记完成后，正式回收垃圾对象。
并发重置，是指在垃圾回收完成后，重新初始化CMS数据结构和数据，为下一次垃圾回收作准备。

在这其中，初始标记和重新标记是独占系统资源的。
而剩余的步骤都是可以和用户线程一起执行的。

CMS收集器在其主要的工作阶段虽然没有暴力地彻底暂停应用程序线程，
但是由于它和应用程序线程并发执行，相互抢占CPU，故在CMS执行期间对应用程序吞吐量将造成一定影响。
CMS默认启动的线程数为(ParallelGCThreads+3)/4，ParallelGCThreads是新生代并行收集器的线程数。
也可以通过-XX:ParallelCMSThreads参数手工设定CMS的线程数量。
当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收的阶段会非常糟糕。

由于CMS收集器不是独占式的回收器，在CMS回收过程中，应用程序仍然在不停的工作。
在应用程序工作过程中，又会不断产生垃圾。
这些新产生的垃圾在当前CMS回收过程中是无法清除的。
同时，因为应用程序没有中断，故在CMS回收过程中，还应该确保应用程序有足够的内存使用。
因此，CMS收集器不会等待堆内存饱和时才进行垃圾回收，而是当堆内存使用率达到阈值时，便开始回收。

这个阈值可以使用-XX:CMSInitiatingOccupancyFraction来制定，这个值默认是68。
即，当老年代的空间使用率达到68%时，会执行一次CMS回收。

如果在CMS执行过程中，已经出现了内存不足的情况，CMS回收就会失败，jvm将启动老年代串行收集器进行回收。
如果这样，应用程序将完全中断，直到垃圾收集完成。

因此，根据应用程序的特点，可以对-XX:CMSInitiatingOccupancyFraction进行调优。
如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率。
反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。

CMS是一个基于标记-清除算法的回收器。
标记-清除算法会造成大量的内存碎片，离散的可用空间无法分配较大的对象。

为了解决这个问题，CMS收集器还提供了几个用于内存压缩整理的参数。
-XX:+UseCMSCompactAtFullCollection开关可以使CMS在垃圾收集完成后，进行一次内存碎片整理。
内存碎片的整理不是并发进行的。
-XX:CMSFullGCsBeforeCompaction参数可以用于设定进行多少次的CMS回收后，进行一次内存压缩。

