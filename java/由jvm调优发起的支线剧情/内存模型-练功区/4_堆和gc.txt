#java堆#

java堆是什么？
java堆可以说是java运行时内存中最为重要的部分。
几乎所有的对象和数组都是在堆中分配空间的。

堆空间是什么结构？
java堆分为新生代和老年代两个部分。
新生代用于存放刚刚产生的对象和年轻的对象。
如果对象一直没有被回收，生存的足够长，老年对象就会被移入老年代。

> 新生代又分为eden（伊甸园）、from space和to space（后两个叫幸存区）。---按照存在时间划分
如果在幸存区的对象到了指定年龄仍然未被回收，则有机会进入老年代（tenured）

为什么要这样划分？

这就要从GC开始说起。

GC是什么？
GC，garbage collection，中文叫垃圾回收。
它是用来自动清空#堆#中 不再使用的对象。

GC优势和不足？（关键字：计算时间）
由于不需要手动释放内存，程序员在编程中也可以减少犯错的机会。
利用垃圾回收，程序员可以避免一些指针和内存泄露相关的bug(这一类bug通常很隐蔽)。
但另一方面，垃圾回收需要耗费更多的计算时间。
垃圾回收实际上是将原本属于程序员的责任转移给计算机。
使用垃圾回收的程序需要更长的运行时间。

什么时候GC回收？

这就要提到引用这个概念。
在Java中，对象的是通过引用使用的。
如果不再有引用指向对象，那么我们就再也无从调用或者处理该对象。
这样的对象将不可到达(unreachable)。
#垃圾回收用于释放不可到达对象所占据的内存。#
这是垃圾回收的基本原则。

早期的垃圾回收采用引用计数(reference counting)的机制。
每个对象包含一个计数器。
当有新的指向该对象的引用时，计数器加1。
当引用移除时，计数器减1。
当计数器为0时，认为该对象可以进行垃圾回收。

然而，一个可能的问题是： 
如果有两个对象循环引用(cyclic reference)，比如两个对象互相引用，
而且此时没有其它(指向A或者指向B)的引用，我们实际上根本无法通过引用到达这两个对象。

因此，我们以栈和static数据为根(root)，从根出发，跟随所有的引用，就可以找到所有的可到达对象。
也就是说，一个可到达对象，一定被根引用，或者被其他可到达对象引用。

这样也就可以初步回答了GC为什么这样划分，
划分以后GC可以首先计算新生代的引用，然后释放该部分空间。
更方便管理。