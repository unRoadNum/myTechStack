# 不公平锁

***
ReentrantLock lock = new ReentrantLock(); //参数默认false，不公平锁      
lock.lock(); //如果被其它资源锁定，会在此等待锁释放，达到暂停的效果    
try {    
    //操作    
} finally {    
    lock.unlock();  //释放锁  
	
***
CPU在调度线程的时候是在等待队列里随机挑选一个线程，由于这种随机性所以是无法保证线程先到先得的（synchronized控制的锁就是这种非公平锁）。
但这样就会产生饥饿现象，即有些线程（优先级较低的线程）可能永远也无法获取CPU的执行权，优先级高的线程会不断的强制它的资源。
那么如何解决饥饿问题呢，这就需要公平锁了。
公平锁可以保证线程按照时间的先后顺序执行，避免饥饿现象的产生。但公平锁的效率比较低，因为要实现顺序执行，需要维护一个有序队列。
