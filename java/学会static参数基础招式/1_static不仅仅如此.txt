#static不仅仅如此#

static能解决了变量的共享问题，我们把它定义成了变量的修饰符关键字。

但是java语言不会仅仅让static去修饰变量，作为变量关键字。
它希望统一起来，跟别的关键字一样，既能修饰变量，也能修饰方法，

正好java在完成的时候有这样的困惑：
为了使得everything is Object，将一些通用的方法都封装在class里面了。
还有一些策略类，本身的方法属于class，或者说属于模板，不属于它的实例; 

比如Math中sin方法：
不可能每次使用都new Math().sin()这样。

看来static如此的契合人意，完美的解决这个问题。

被static修饰的方法，可以直接用类名.方法名来使用。

这个时候，我们就需要研究另一个问题了。
既然被static修饰的变量、方法都属于类本身，而被所有实例共享。
那它什么时候运行呢？

因为jvm执行的class字节码文件，是一个从加载到卸载的全过程。
那就说明任何类都需要是一个从加载到卸载的全过程。

这就不得不研究一下java设计者们，是如何控制一个类的生命周期，以便于jvm更好的执行了。




