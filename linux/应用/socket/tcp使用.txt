## tcp使用
众所周知，tcp是建立连接后，然后再相互send/recv message的。
那么，第一步肯定是想建立连接的tcp两端要建立连接。
仔细看，我用了"想建立连接的tcp的两端"，而不是用客户端和服务器端，为什么呢？
我是这样考虑的，在我想构建一个tcp连接前是不知道什么客户端和服务器这种角色划分的，我只是简单的想让双方通信的。
至于说服务器和客户端，我觉得应该是在应用中重新给两端定义了名称，它的名称不应该出现在tcp层，也就是传输层。
要完成这第一步：
首先双端获取socket，想要请求的一方（ps：暂且就叫做请求方吧，后期有可能角色发生变化，但是因为它是最先主动的，叫它请求方一点也不过分）要获取对方的
ip地址和端口号，才能将请求发送给对端（就叫做应答方吧）。那就说应答方得bind自己的地址，如果它的地址不固定，请求方永远没办法找它办事。
> bind()函数主要的目的是将socket和ip地址:port号关联上，这样通信的一方的地址就永远不会发生变化。如果不使用bind的话，send函数就随机使用一个端口号来跟对端通信。
其次，tcp规定这个应答方是可以允许多个请求方发送请求到自己这里来的，那么它在连接之前必须限制连接请求数，要不它自己的资源就会被瞬间耗尽。
这个功能也是系统提供给用户自己来做这个事情，也就是listen函数来完成这个功能。
最后，完成以上所有的准备工作，以后请求方就可以connect，然后应答方检查连接数在允许方范围内，则accept连接，至此完成这第一步：建立连接。
那么，总结一下第一步双方完成了哪些具体的操作：
- 应答方
	- socket
	- bind
	- listen
	- accept
- 请求方
	- socket
	- connect
当然，请求方在connect之前也是可以bind自己的端口号的。如果请求方没有bind自己的端口号，协议栈会随机选取一个未被占用的端口号跟应答方进行连接。
第二步，请求方和应答方进行通信。
在这里我们对比之前的udp通信，udp通信使用了sendto和recvfrom。
#### 因为sendto是可以明确指定发送到对端地址，recvfrom可以从收到的消息中获取对端地址。
而后面用的write/read和recv/send却不能做到这些，所以在udp中就使用了sendto和recvfrom。
#### 但是，我们在tcp中当然也可以使用这两个函数。
比如我们可以在应答方使用recvfrom去获取请求方的地址（虽然请求方知道应答方的地址，但是应答方如果不主动获取请求方的地址，它是不会知道该内容的）。
#### 在tcp中，习惯用send/recv和wirte/read来通信。
最后一步，通信完成以后，close socket就行了。
	
