## tcp三次握手
重要的话说在前面，三次握手的意义是同步seq，即syn seq。
我们先看看tcp三次握手的具体过程，以下发送方指的是第一次发送数据包的一端，接收方就不说了。
1. 首先发送方发送第一个数据包，告诉接收方自己的seq：SYN=1 seq=x
	* syn标记位置1，告诉对端这是tcp的同步seq报文
	* seq字段携带发送方自己的报文序号x
2. 接收方收到发送方的syn报文后，确认并告诉对端自己的seq：ACK=1 SYN=1 ack=x+1 seq=y
	* ACK标记位置1，ack字段携带确认报文ack=x+1
	* SYN标记位置1，seq字段携带接收方自己的报文序号y
3. 发送方收到接收方的syn响应+请求报文后，确认自己的seq：ACK=1 ack=y+1 seq=x+1
	* ACK标记位置1，ack字段携带确认报文ack=y+1
	
其实，tcp的三次握手完成的4件事，但是为了网络吞吐量，生生将4件事利用3次握手就完成了。
在tcp的握手的过程中，接收方和发送方处于一种"安全"的状态，类似于被synchronized锁保护起来一样。
在这种"安全"的状态下，不会有第三方参与进来，所以完全可以优化将ACK和SYN包合成一次完成。
如果将接收方的ACK报文独立起来，它不带任何数据，但是网络中成千上万万的tcp连接就会给物理网络带来不少的压力，
将它和SYN报文合成一次，网络吞吐会明显的提高。
***
仔细的研究一下，你会发现ack的内容为什么会是x+1、y+1这种呢？不是应该x、y更符合实际吗？
似乎是这样的，当发送端发送一个数据包，接收端ack一个数据包，理所当然，顺利成章。
我们自己可能在v1.0版本中，就这样搞了。
但是搞tcp/ip的人是一群什么人，那是当时的社会精英，top100的工程师啊。
肯定比我们有经验，原谅我这里这么说（手动斜眼）。

一袋烟的功夫，我似乎找到了些原因：
因为ack不仅仅是对syn的啊，也有很多其他类别的request，也要ack啊。
而其他类别的request数据包长度似乎并不是一个字节，这样ack的方便之处就出来了。
因为ack字段填的是当前收到对端的序列号+收到的包数据字节数。
这样，发送端根据收到ack，就可以很轻松找到下一个要发送的数据包起始位置
如果不这样的话，你就得去查找上个数据包到底发送了多少个字节，然后用ack自己计算。
这就要去存储然后查询了，显然这是不可取的。

***
* tcp优化一对一的requset/answer *
以下是插入的思考，跟tcp的三次握手无关，可跳过。
在这其中因为当前网络的稳定性的发展，一对一的request/answer显然是低效率的。
tcp显然不会这么干，它发送完一个request后，不会等待answer到，会连续发送多个req，
接收端在收到连续的requests后，只会发送一个answer给发送方，表示ack以前的数据包全部收到，
后面的如果定时器超时后，还没有收到包含ack的answer，则认为丢包。
这样做了以后，会发现纵然会出现重复发送ack后的某些包，但是相比这些代价，更多的是比一对一的request/answer大幅度的增加了网络吞吐量。
***
说了这么多，还有一个问题，我们没有解决，就是：
* 发送方握手的最后一个ACK包丢了，怎么办？ *
按照我们之前的设想，丢包就应该超时重传该包，来解决这个问题。
那我们*假设*重传这个ACK包试一下，咦，怎么判断超时了呢？
通常的超时重传都是依靠响应的，单纯的ack（特制没有数据的ack）是没有响应的，根本就没有办法判断超时。
最好的办法是由* 接收方在判断没有握手的最后一个ack的时候，重传syn+ack，即重传第二次握手包来解决这个问题*。
完美啊，完美，目前我感觉tcp比我厉害多了啊。

上文说了，*没有数据的ack是没有响应的*，也就是说*在握手的最后一次ack可以携带数据的*，这样可以更大的提高网络吞吐。
*不仅仅是ack，没有数据的tcp包都是没有响应的*。
所以，设计tcp的工程师们又有意*将SYN的标志位设置为占用一个字节编号（FIN标志位也是）*。
这样，也*解释了syn报文没有携带数据，为什么会有ACK响应包，且ack=seq+1了*。


